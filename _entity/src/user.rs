//! SeaORM Entity. Generated by sea-orm-codegen 0.8.0
use crate::{locale::Locale, user_info};

use super::temp_user;
use chrono::Utc;
use sea_orm::{entity::prelude::*, Set};
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "user")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: Uuid,
    #[sea_orm(unique)]
    pub google_id: String,
    #[sea_orm(unique)]
    pub email: String,
    pub avatar_url: String,
    pub name: String,
    pub first_name: String,
    pub last_name: String,
    pub created_at: DateTimeUtc,
    pub updated_at: DateTimeUtc,
}

// impl RelationTrait for Relation {
//     fn def(&self) -> RelationDef {
//         match self {
//             Self::UserInfo => Entity::has_one(user_info::Entity).into(),
//         }
//     }
// }

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_one = "user_info::Entity")]
    UserInfo,
}

impl ActiveModelBehavior for ActiveModel {}

#[derive(Serialize, Deserialize)]
pub struct NewModel {
    pub first_name: String,
    pub last_name: String,
    pub gender: String,
    pub birth_date: Date,
    pub phone: String,
}

impl NewModel {
    pub fn into_with_temp_user(self, m: temp_user::Model) -> ActiveModel {
        let now = Utc::now();

        ActiveModel {
            id: Set(Uuid::new_v4()),
            google_id: Set(m.google_id),
            email: Set(m.email),
            avatar_url: Set(m.avatar_url),
            name: Set(m.name),
            first_name: Set(self.first_name),
            last_name: Set(self.last_name),
            created_at: Set(now),
            updated_at: Set(now),
        }
    }
}
